import { sqliteTable, text, integer, index, unique } from "drizzle-orm/sqlite-core";
import { relations } from "drizzle-orm";

export const channels = sqliteTable(
  "channels",
  {
    id: text("id").primaryKey(),
    channelId: text("channel_id").notNull().unique(), // YouTube channel ID
    channelTitle: text("channel_title").notNull(),
    channelDescription: text("channel_description"),
    channelUrl: text("channel_url"),
    thumbnailUrl: text("thumbnail_url"), // Channel profile photo URL
    thumbnailPath: text("thumbnail_path"), // Local file path for channel photo
    bannerUrl: text("banner_url"), // Channel banner image URL
    subscriberCount: integer("subscriber_count"),
    videoCount: integer("video_count"),
    viewCount: integer("view_count"),
    customUrl: text("custom_url"), // e.g., @channelname
    raw: text("raw_json"), // Raw JSON metadata from YouTube

    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("channels_channel_id_idx").on(table.channelId),
    index("channels_updated_at_idx").on(table.updatedAt),
  ]
);

export const youtubeVideos = sqliteTable(
  "youtube_videos",
  {
    id: text("id").primaryKey(),
    videoId: text("video_id").notNull(), // YouTube video ID
    title: text("title").notNull(),
    description: text("description"),
    channelId: text("channel_id").references(() => channels.channelId), // Reference to channels table
    channelTitle: text("channel_title"), // Denormalized for backward compatibility
    durationSeconds: integer("duration_seconds"),
    viewCount: integer("view_count"),
    likeCount: integer("like_count"),
    thumbnailUrl: text("thumbnail_url"),
    thumbnailPath: text("thumbnail_path"), // local file path after download
    publishedAt: integer("published_at"),
    tags: text("tags"), // comma-separated or JSON
    raw: text("raw_json"), // raw JSON metadata string

    // Consolidated download fields (single-version per video)
    downloadStatus: text("download_status", {
      enum: [
        "pending",
        "downloading",
        "completed",
        "failed",
        "cancelled",
        "queued",
        "paused",
      ],
    }),
    downloadProgress: integer("download_progress"), // 0-100
    downloadFormat: text("download_format"),
    downloadQuality: text("download_quality"),
    downloadFilePath: text("download_file_path"),
    downloadFileSize: integer("download_file_size"),
    lastErrorMessage: text("last_error_message"),
    errorType: text("error_type"), // 'restricted' | 'network' | 'format' | 'unknown'
    isRetryable: integer("is_retryable", { mode: "boolean" }),
    lastDownloadedAt: integer("last_downloaded_at"),

    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("youtube_videos_video_id_idx").on(table.videoId),
    index("youtube_videos_published_at_idx").on(table.publishedAt),
    unique().on(table.videoId), // one entry per video
  ]
);

// Transcripts per video (optionally multiple languages)
export const videoTranscripts = sqliteTable(
  "video_transcripts",
  {
    id: text("id").primaryKey(),
    videoId: text("video_id").notNull(),
    // ISO language code if known (e.g., "en", "en-US"); may be null when unknown
    language: text("language"),
    // Whether transcript is auto-generated by YouTube
    isAutoGenerated: integer("is_auto_generated", { mode: "boolean" }).default(false),
    // Source of the transcript data (e.g., "yt-dlp")
    source: text("source"),
    // Full plain-text transcript content
    text: text("text"),
    // Raw VTT content saved for caching and re-processing
    rawVtt: text("raw_vtt"),
    // Cached segments derived from VTT (JSON string of Array<{start,end,text}>)
    segmentsJson: text("segments_json"),

    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("video_transcripts_video_id_idx").on(table.videoId),
    // Allow at most one transcript per language per video
    unique().on(table.videoId, table.language),
  ]
);

// Annotations/comments on videos tied to timestamps
export const videoAnnotations = sqliteTable(
  "video_annotations",
  {
    id: text("id").primaryKey(),
    videoId: text("video_id").notNull(),
    // Timestamp in seconds (e.g., 125.5 for 2:05.5)
    timestampSeconds: integer("timestamp_seconds").notNull(),
    // The text the user selected from the transcript
    selectedText: text("selected_text"),
    // The note/comment the user added
    note: text("note").notNull(),
    // Emoji reaction for quick categorization (â“ confused, ðŸ’¡ insight, â­ important, ðŸ”– bookmark)
    emoji: text("emoji"),

    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("video_annotations_video_id_idx").on(table.videoId),
    index("video_annotations_timestamp_idx").on(table.timestampSeconds),
  ]
);

export const channelPlaylists = sqliteTable(
  "channel_playlists",
  {
    id: text("id").primaryKey(),
    playlistId: text("playlist_id").notNull().unique(),
    channelId: text("channel_id").references(() => channels.channelId),
    title: text("title").notNull(),
    description: text("description"),
    thumbnailUrl: text("thumbnail_url"),
    thumbnailPath: text("thumbnail_path"),
    itemCount: integer("item_count"),
    url: text("url"),
    raw: text("raw_json"),

    // Playback stats
    viewCount: integer("view_count").default(0), // Number of times playlist was opened
    lastViewedAt: integer("last_viewed_at"), // Last time playlist was viewed
    currentVideoIndex: integer("current_video_index").default(0), // Current position in playlist
    totalWatchTimeSeconds: integer("total_watch_time_seconds").default(0), // Total watch time across all videos

    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
    lastFetchedAt: integer("last_fetched_at"),
  },
  (table) => [
    index("channel_playlists_channel_id_idx").on(table.channelId),
    index("channel_playlists_updated_at_idx").on(table.updatedAt),
    index("channel_playlists_last_viewed_at_idx").on(table.lastViewedAt),
  ]
);

// Junction table: stores which videos belong to which playlists and their order
export const playlistItems = sqliteTable(
  "playlist_items",
  {
    id: text("id").primaryKey(),
    playlistId: text("playlist_id").notNull().references(() => channelPlaylists.playlistId, { onDelete: "cascade" }),
    videoId: text("video_id").notNull().references(() => youtubeVideos.videoId, { onDelete: "cascade" }),
    position: integer("position").notNull(), // 0-based position in playlist

    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("playlist_items_playlist_id_idx").on(table.playlistId),
    index("playlist_items_video_id_idx").on(table.videoId),
    index("playlist_items_position_idx").on(table.playlistId, table.position),
    // Ensure no duplicate videos in the same playlist
    unique().on(table.playlistId, table.videoId),
  ]
);

// Watch stats per video (accumulated)
export const videoWatchStats = sqliteTable(
  "video_watch_stats",
  {
    id: text("id").primaryKey(),
    videoId: text("video_id").notNull().unique(),
    totalWatchSeconds: integer("total_watch_seconds").default(0),
    lastPositionSeconds: integer("last_position_seconds").default(0),
    lastWatchedAt: integer("last_watched_at"),
    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    index("video_watch_stats_video_id_idx").on(table.videoId),
    index("video_watch_stats_last_watched_at_idx").on(table.lastWatchedAt),
  ]
);

// Define relations
export const channelsRelations = relations(channels, ({ many }) => ({
  videos: many(youtubeVideos),
  playlists: many(channelPlaylists),
}));

export const youtubeVideosRelations = relations(youtubeVideos, ({ one }) => ({
  channel: one(channels, {
    fields: [youtubeVideos.channelId],
    references: [channels.channelId],
  }),
}));

export const channelPlaylistsRelations = relations(channelPlaylists, ({ one, many }) => ({
  channel: one(channels, {
    fields: [channelPlaylists.channelId],
    references: [channels.channelId],
  }),
  items: many(playlistItems),
}));

export const playlistItemsRelations = relations(playlistItems, ({ one }) => ({
  playlist: one(channelPlaylists, {
    fields: [playlistItems.playlistId],
    references: [channelPlaylists.playlistId],
  }),
  video: one(youtubeVideos, {
    fields: [playlistItems.videoId],
    references: [youtubeVideos.videoId],
  }),
}));

export type VideoWatchStat = typeof videoWatchStats.$inferSelect;
export type NewVideoWatchStat = typeof videoWatchStats.$inferInsert;

// TypeScript types derived from Drizzle schema
export type Channel = typeof channels.$inferSelect;
export type NewChannel = typeof channels.$inferInsert;

export type YoutubeVideo = typeof youtubeVideos.$inferSelect;
export type NewYoutubeVideo = typeof youtubeVideos.$inferInsert;

export type ChannelPlaylist = typeof channelPlaylists.$inferSelect;
export type NewChannelPlaylist = typeof channelPlaylists.$inferInsert;

export type PlaylistItem = typeof playlistItems.$inferSelect;
export type NewPlaylistItem = typeof playlistItems.$inferInsert;

// User preferences (singleton table, single row with id='default')
export const userPreferences = sqliteTable("user_preferences", {
  id: text("id").primaryKey().notNull().default("default"),
  preferredLanguages: text("preferred_languages").notNull().default("[]"), // JSON array of language codes like ["en", "es", "fr"]
  systemLanguage: text("system_language"), // Detected system language (read-only after first detect)
  createdAt: integer("created_at").notNull(),
  updatedAt: integer("updated_at"),
});

export type UserPreferences = typeof userPreferences.$inferSelect;
export type NewUserPreferences = typeof userPreferences.$inferInsert;

// Translation cache table to avoid redundant Google API calls
// Also tracks user query patterns for learning/memory features
export const translationCache = sqliteTable(
  "translation_cache",
  {
    id: text("id").primaryKey(),
    // Original text to translate
    sourceText: text("source_text").notNull(),
    // Source language code (e.g., "en", "es", "auto")
    sourceLang: text("source_lang").notNull(),
    // Target language code (e.g., "en", "es")
    targetLang: text("target_lang").notNull(),
    // The translated text result
    translatedText: text("translated_text").notNull(),
    // Detected source language (in case sourceLang was "auto")
    detectedLang: text("detected_lang"),

    // Query tracking for learning/memory features
    // Number of times user requested this translation
    queryCount: integer("query_count").notNull().default(1),
    // First time this translation was requested
    firstQueriedAt: integer("first_queried_at").notNull(),
    // Most recent time this translation was requested
    lastQueriedAt: integer("last_queried_at").notNull(),

    createdAt: integer("created_at").notNull(),
    updatedAt: integer("updated_at"),
  },
  (table) => [
    // Unique constraint on sourceText + sourceLang + targetLang to prevent duplicates
    unique().on(table.sourceText, table.sourceLang, table.targetLang),
    // Index for faster lookups
    index("translation_cache_lookup_idx").on(table.sourceText, table.sourceLang, table.targetLang),
    // Index for finding frequently queried translations
    index("translation_cache_query_count_idx").on(table.queryCount),
    // Index for recent queries
    index("translation_cache_last_queried_idx").on(table.lastQueriedAt),
  ]
);

export type TranslationCache = typeof translationCache.$inferSelect;
export type NewTranslationCache = typeof translationCache.$inferInsert;

// Translation contexts - links translations to specific videos and timestamps
// This allows users to see where they translated each word and jump back to that moment
export const translationContexts = sqliteTable(
  "translation_contexts",
  {
    id: text("id").primaryKey(),
    // Foreign key to translation_cache
    translationId: text("translation_id").notNull().references(() => translationCache.id, { onDelete: "cascade" }),
    // Video where this translation occurred
    videoId: text("video_id").notNull(),
    // Timestamp in seconds where the word appeared
    timestampSeconds: integer("timestamp_seconds").notNull(),
    // The surrounding text/context from the transcript
    contextText: text("context_text"),

    createdAt: integer("created_at").notNull(),
  },
  (table) => [
    index("translation_contexts_translation_id_idx").on(table.translationId),
    index("translation_contexts_video_id_idx").on(table.videoId),
    // Prevent duplicate contexts for same translation in same video at same timestamp
    unique().on(table.translationId, table.videoId, table.timestampSeconds),
  ]
);

export type TranslationContext = typeof translationContexts.$inferSelect;
export type NewTranslationContext = typeof translationContexts.$inferInsert;
